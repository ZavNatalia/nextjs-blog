---
title: 'Как думать о безопасности в Next.js'
date: '2024-10-23'
image: 'how-to-think-about-security-in-next-js.webp'
excerpt: 'React Server Components (RSC) в App Router — это новая парадигма, которая устраняет многие избыточности и потенциальные риски, связанные с традиционными методами. Учитывая новизну, разработчикам и, следовательно, командам безопасности может быть сложно согласовать свои существующие протоколы безопасности с этой моделью.'
isFeatured: true
---

React Server Components (RSC) в App Router — это новая парадигма, которая устраняет много избыточности и потенциальных рисков, связанных с традиционными методами. Поскольку технология новая, разработчикам и командам по безопасности может быть сложно адаптировать существующие протоколы безопасности к этой модели.

Этот документ выделяет ключевые области для внимания, описывает встроенные защиты и предоставляет руководство по аудиту приложений. Особое внимание уделяется рискам случайного раскрытия данных.

### Выбор Модели Обработки Данных

![Illustration of HTTP APIs and Zero Trust for a Next.js project ](http-apis-and-zero-trust-in-the-context-of-server-components.webp)

React Server Components размывают границы между сервером и клиентом. Важно понимать, где обрабатываются данные и где они становятся доступными.

Первым шагом необходимо выбрать подходящий способ обработки данных для вашего проекта:

1. **HTTP API** (рекомендуется для крупных существующих проектов/организаций)
2. **Слой Доступа к Данных (Data Access Layer)** (рекомендуется для новых проектов)
3. **Доступ к Данным на Уровне Компонента** (рекомендуется для прототипирования и обучения)

Рекомендуется придерживаться одного подхода, чтобы было понятно как разработчикам, так и аудиторам безопасности, чего ожидать. Исключения будут выглядеть подозрительно.

### HTTP API

Если вы внедряете Server Components в существующий проект, рекомендуется обрабатывать Server Components как небезопасные по умолчанию, аналогично SSR или клиентской обработке. Это позволяет применять концепцию Zero Trust, где инженеры могут вызывать только собственные API-эндпоинты, такие как REST или GraphQL, используя _fetch()_ из Server Components, как если бы они выполнялись на клиенте, передавая куки.

**Что нужно учитывать:**

-   Избегайте контроля доступа, предполагающего безопасность внутренних сетей.
-   Переносите существующие _getStaticProps_, _getServerSideProps_ в API-эндпоинты для единообразия.
-   Это позволяет сохранять существующие структуры организации и использовать проверенные практики безопасности.

### Слой Доступа к Данных (Data Access Layer)

Для новых проектов рекомендуется создать отдельный слой доступа к данным внутри вашего JavaScript-кода и централизовать весь доступ к данным там. Это обеспечивает последовательность доступа и уменьшает вероятность ошибок авторизации.

**Преимущества:**

-   Лёгкость в обслуживании благодаря централизованной библиотеке.
-   Улучшенная производительность с низкими накладными расходами.
-   Возможность использования кэша в памяти для разных частей запроса.

**Пример:**

```javascript
// data/auth.tsx
import { cache } from 'react';
import { cookies } from 'next/headers';

export const getCurrentUser = cache(async () => {
  const token = cookies().get('AUTH_TOKEN');
  const decodedToken = await decryptAndValidate(token);
  return new User(decodedToken.id);
});

// data/user-dto.tsx
import 'server-only';
import { getCurrentUser } from './auth';

export async function getProfileDTO(slug: string) {
  const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`;
  const userData = rows[0];
  const currentUser = await getCurrentUser();

  return {
    username: canSeeUsername(currentUser) ? userData.username : null,
    phonenumber: canSeePhoneNumber(currentUser, userData.team) ? userData.phonenumber : null,
  };
}
```

### Доступ к Данных на Уровне Компонента

Другой подход — напрямую вставлять запросы к базе данных в Server Components. Этот метод подходит только для быстрой разработки и прототипирования.

**Важно:**

-   Внимательно проверяйте файлы с _use client_.
-   Убедитесь, что компоненты не принимают избыточные данные.

**Пример:**

```javascript
// app/page.tsx
export async function Page({ params: { slug } }) {
    const [rows] = await sql`SELECT * FROM user WHERE slug = ${slug}`;
    const userData = rows[0];
    return <Profile user={userData} />;
}

// BAD: Компонент получает слишком много данных
export default function Profile({ user }) {
    return (
        <div>
            <h1>{user.name}</h1>
            ...
        </div>
    );
}
```

### Только Серверный Код

Код, который должен выполняться только на сервере, можно отметить следующим образом:

```javascript
import 'server-only';
```

Это предотвратит импорт этого модуля в клиентские компоненты и защитит чувствительную логику от утечки на клиент.

### SSR vs RSC

При первоначальной загрузке Next.js выполняет как Server Components, так и Client Components на сервере для создания HTML.

**Основные моменты:**

-   Server Components работают в отдельной системе модулей для предотвращения утечки информации.
-   Client Components должны рассматриваться с точки зрения безопасности как код, выполняемый в браузере.

### Чтение и Запись Данных

**Чтение данных:**

-   Всегда проверяйте контроль доступа и куки при чтении данных.
-   Избегайте побочных эффектов при рендеринге Server Components.

**Запись данных:**

-   Используйте Server Actions для выполнения изменений.
-   Всегда проверяйте права пользователя и целостность входных данных.

**Пример Server Action:**

```javascript
// actions.ts
'use server';

export async function deletePost(id: number) {
  if (typeof id !== 'number') {
    throw new Error();
  }
  const user = await getCurrentUser();
  if (!canDeletePost(user, id)) {
    throw new Error();
  }
  ...
}
```

### Защита от CSRF

Server Actions могут быть подвержены атакам CSRF, поэтому Next.js использует POST-запросы и проверяет заголовки Origin и Host для дополнительной защиты.

**Рекомендации:**

-   Используйте только POST для Server Actions.
-   Избегайте использования GET-запросов для выполнения изменений.

### Обработка Ошибок

Ошибки на сервере могут содержать чувствительную информацию. В режиме продакшн React не отправляет детали ошибок на клиент, а вместо этого отправляет хеш, связанный с логами на сервере. Всегда запускайте Next.js в режиме продакшн для повышения безопасности и производительности.

### Пользовательские Маршруты и Middleware

Пользовательские обработчики маршрутов и Middleware предоставляют мощные возможности, но требуют тщательного аудита для предотвращения уязвимостей.

**Рекомендации:**

-   Ограничивайте доступ с помощью белых списков.
-   Регулярно проводите тестирование на проникновение и сканирование уязвимостей.

### Аудит Безопасности

![Abstract 3D representations of the audit process for a Next.js App Router project](audit-of-a-Next-js-App-Router-project.webp)

При аудите проекта на Next.js App Router обратите внимание на:

-   Слой доступа к данным: Изолирован ли он? Не импортируются ли пакеты базы данных вне слоя?
-   Файлы с _use client_: Не ожидают ли пропсы приватных данных? Не слишком ли широки сигнатуры типов?
-   Файлы с _use server_: Валидируются ли аргументы действий? Переавторизуется ли пользователь внутри действия?
-   Параметры URL (_/[param]/_): Валидируются ли они?
-   Middleware и маршруты: Требуют ли они дополнительного аудита?

---

**Автор оригинального поста:** [Sebastian Markbåge (@sebmarkbage)](https://twitter.com/sebmarkbage)
